<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>AR：宇航员粘在二维码上</title>

  <!-- 关键：用 importmap 明确 three 与 mindar 的 ES 模块（官方推荐写法） -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "mindar-image-three": "https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"
    }
  }
  </script>

  <style>
    /* 强制全屏 & 禁止滚动/回弹 */
    html, body {
      margin: 0; padding: 0;
      width: 100vw; height: 100dvh;
      overflow: hidden;
      background: #000;
      overscroll-behavior: none;
      touch-action: none;
    }
    /* AR 容器：固定全屏 */
    #ar {
      position: fixed; inset: 0;
      width: 100vw; height: 100dvh;
      background: #000; overflow: hidden;
    }
    /* MindAR 注入的 video/canvas/overlay 铺满容器 */
    #ar video, #ar canvas, #ar .mindar-ui-overlay, #ar .mindar-ui-scanning {
      position: absolute !important;
      inset: 0 !important;
      width: 100% !important; height: 100% !important;
      max-width: 100% !important; max-height: 100% !important;
      display: block !important;
      object-fit: cover;
      overflow: hidden;
    }
    /* 控件置顶 */
    #enter {
      position: fixed; left: 50%; bottom: 24px; transform: translateX(-50%);
      z-index: 9999; padding: 12px 18px;
      border: 0; border-radius: 999px; background: #8892ff; color: #111; font-weight: 700;
      pointer-events: auto;
    }
    #hint {
      position: fixed; left: 12px; right: 12px; bottom: 72px;
      z-index: 9999; color: #9ad; font: 14px/1.5 system-ui; text-shadow: 0 1px 2px #000;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="ar"></div>
  <button id="enter">进入 AR</button>
  <div id="hint">允许相机后，对准你桌上/墙上的二维码。</div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { MindARThree } from 'mindar-image-three'; // ✅ 不再用 esm.sh/esm.run

    // -------- 资源与参数 --------
    const MODEL_URL     = 'yuhangyuan.glb';  // 宇航员
    const TARGET_URL    = 'qr-target.mind';  // 用二维码图编译出的 .mind
    const MODEL_SCALE   = 0.05;              // 模型缩放
    const EPSILON_LIFT  = 0.002;             // 抬脚 2mm 防穿插
    // MindAR 中目标平面法线沿 Z；若脚朝向反了，把 'posZ' 改 'negZ'
    const ALIGN_TO      = 'posZ';            // 'posZ' | 'negZ'

    const $ = (s)=>document.querySelector(s);
    const container = $('#ar');
    const enterBtn  = $('#enter');
    const hintEl    = $('#hint');
    const hint = (t)=>{ hintEl.textContent = t || ''; };

    let started = false;

    enterBtn.addEventListener('click', async () => {
      if (started) return; started = true; enterBtn.style.display = 'none';
      hint('正在启动相机…');

      try {
        // ① 初始化 MindARThree（稳定性优先的参数）
        const mindarThree = new MindARThree({
          container,
          imageTargetSrc: TARGET_URL,
          maxTrack: 1,                 // 只跟踪一个目标，减负载
          uiLoading: 'no', uiScanning: 'no', uiError: 'yes',

          // 内置姿态滤波（OneEuro），越小越稳（但跟手差）
          filterMinCF: 0.0005,
          filterBeta: 0.005,

          // 事件防抖：减少“刚识别/刚丢失”的闪烁
          warmupTolerance: 3,  // 连续3帧才算真正找到
          missTolerance: 12    // 连续12帧才算真正丢失
        });
        const { renderer, scene, camera } = mindarThree;

        // ② Three 光照
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444466, 0.7));
        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(1,2,1); scene.add(dir);

        // ③ 锚点（.mind 的第 0 个目标）
        const anchor = mindarThree.addAnchor(0);

        // ④ “二次平滑容器” + “脚贴平面”的 peg
        //    不直接把模型挂在 anchor.group，下层再做 LERP/SLERP 平滑，减少抖动
        const smoothed = new THREE.Group();  // 二次平滑容器
        scene.add(smoothed);

        const peg = new THREE.Group();       // 让模型的本地 +Y 轴对齐到目标法线（Z）
        smoothed.add(peg);
        {
          const from = new THREE.Vector3(0,1,0);
          const to   = (ALIGN_TO === 'negZ') ? new THREE.Vector3(0,0,-1) : new THREE.Vector3(0,0,1);
          peg.quaternion.copy(new THREE.Quaternion().setFromUnitVectors(from, to));
        }

        // ⑤ 目标丢失/找回的“缓冲隐藏”，防闪烁
        let loseTimer = null;
        anchor.onTargetFound = () => { clearTimeout(loseTimer); smoothed.visible = true; };
        anchor.onTargetLost  = () => { loseTimer = setTimeout(()=> smoothed.visible = false, 400); }; // 400ms 宽限

        // ⑥ 载入模型，并把“脚底”贴到 peg 的 y=0 平面
        const loader = new GLTFLoader();
        loader.load(MODEL_URL, (gltf)=>{
          const model = gltf.scene;
          // 若更追求帧率，可把阴影关掉（已默认关）
          model.traverse(o => { if (o.isMesh){ o.castShadow = false; o.receiveShadow = false; }});
          model.scale.setScalar(MODEL_SCALE);

          const box = new THREE.Box3().setFromObject(model);
          const footYOffset = -box.min.y + EPSILON_LIFT; // 脚底抬到 y=0（微抬 2mm）
          model.position.set(0, footYOffset, 0);

          peg.add(model);
          hint('对准二维码：宇航员会用“脚”粘在二维码平面上（不管躺着还是竖着）。');
        }, undefined, (err)=>{ console.warn(err); hint('模型加载失败'); });

        // ⑦ 启动 MindAR
        await mindarThree.start();

        // ⑧ 渲染器按容器尺寸设置（像素比上限 1.5 更稳）
        function sizeToContainer() {
          const w = container.clientWidth, h = container.clientHeight;
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
          renderer.setSize(w, h, false);  // 不改 canvas 样式宽高
        }
        sizeToContainer();
        window.addEventListener('resize', sizeToContainer);

        // ⑨ 动画循环：读取 anchor.group 的世界姿态 → 二次平滑到 smoothed
        const tmpPos = new THREE.Vector3(), tmpQuat = new THREE.Quaternion(), tmpScale = new THREE.Vector3();
        const SMOOTH_POS_ALPHA = 0.20;   // 位置平滑（0~1，越小越稳）
        const SMOOTH_ROT_ALPHA = 0.25;   // 旋转平滑
        const SMOOTH_SCL_ALPHA = 0.30;   // 缩放平滑

        renderer.setAnimationLoop(() => {
          // 从 anchor.group 读取世界姿态
          anchor.group.matrixWorld.decompose(tmpPos, tmpQuat, tmpScale);

          // 首帧直接对齐，之后做插值
          if (!smoothed.userData.init) {
            smoothed.position.copy(tmpPos);
            smoothed.quaternion.copy(tmpQuat);
            smoothed.scale.copy(tmpScale);
            smoothed.userData.init = true;
          } else {
            smoothed.position.lerp(tmpPos, SMOOTH_POS_ALPHA);
            smoothed.quaternion.slerp(tmpQuat, SMOOTH_ROT_ALPHA);
            smoothed.scale.lerp(tmpScale, SMOOTH_SCL_ALPHA);
          }

          renderer.render(scene, camera);
        });
      } catch (e) {
        console.error(e);
        hint('启动失败：' + (e?.message || e));
        enterBtn.style.display = 'block';
      }
    });
  </script>
</body>
</html>
